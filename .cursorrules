# Fonana Project Intelligence 1

## Critical Architecture Patterns

### Database Schema Reality
- **NEVER assume Prisma schema matches database**: Always verify actual table structure via psql
- **Missing fields pattern**: Frontend expects `name`, `username`, `backgroundImage`, `subscribers` but database only has `nickname`, `fullName`, `bio`, `avatar`
- **Safe database access**: Always check `fonana/fonana_user:fonana_pass@localhost:5432` for actual structure
- **Data normalization required**: Use PostNormalizer service to bridge schema gaps

### API Strategy Pattern
- **Simplified API approach**: Use route-simple.ts versions that avoid complex Prisma relationships
- **API verification**: Always test endpoints via `/api/creators` and `/api/posts` before frontend work
- **Broken relationship handling**: Skip complex joins that reference non-existent fields

### Frontend Component Safety
- **Null safety critical**: Components like CreatorsExplorer crash on undefined property access
- **Fallback values required**: Always provide defaults for missing creator properties
- **TypeScript mismatches**: Interfaces don't match database reality - add runtime checks

### Development Workflow
- **Document before fix**: Never attempt architectural fixes "on the fly" - creates more problems
- **Playwright testing**: Use browser testing to verify actual rendering vs API responses
- **Memory Bank first**: Always read Memory Bank files before any code changes

## ðŸŽ¯ **IDEAL METHODOLOGY Integration**

### **Systematic Debugging Patterns (2025-018)**
Based on successful SparklesIcon error resolution:

#### **HeroIcons Import Errors**
- **Symptom**: `ReferenceError: [IconName] is not defined`
- **Root Cause**: Missing import in component file
- **Diagnosis**: Use `grep_search` to find icon usage vs imports
- **Solution**: Add missing icon to existing `import { } from '@heroicons/react/24/outline'`
- **Validation**: Playwright MCP reproduction with browser console monitoring
- **Time**: ~10 minutes with IDEAL METHODOLOGY

#### **React setState Warnings Pattern**
- **Symptom**: `Cannot update component while rendering another component`
- **Root Cause**: Usually secondary effect of JavaScript ReferenceError in render
- **Fix Strategy**: Resolve primary error (missing import) â†’ setState warning disappears
- **Don't**: Try to fix setState warning directly without addressing root cause

#### **Conditional Rendering Errors**
- **Pattern**: Errors occur only with specific data types (e.g., tip messages with JWT tokens)
- **Discovery Method**: Playwright MCP navigation to different scenarios
- **Key Insight**: Error shows only when component reaches specific rendering path
- **Testing**: Always test both "No JWT" and "With JWT" scenarios

### **Playwright MCP Debug Strategy**
```javascript
// Standard debugging automation sequence:
// 1. Navigate to problem URL
await page.goto('http://localhost:3000/messages/[id]');

// 2. Collect console evidence
const console_logs = await browser_console_messages();

// 3. Check for specific error patterns
const errors = console_logs.filter(m => m.includes('ReferenceError'));

// 4. Validate fix by repeating navigation
// Expected: 0 errors after fix
```

### **7-File System Success Patterns**
- **Discovery Phase**: Playwright MCP reproduction critical for accurate diagnosis
- **Impact Analysis**: Always classify risks (Critical/Major/Minor) before coding
- **Implementation Simulation**: Model all edge cases before actual changes
- **Browser Validation**: Real-world testing prevents theoretical solutions
- **Time Efficiency**: 10-minute fix with 1-hour analysis prevents days of debugging

## User Preferences

### Communication Style
- **Language**: Respond in Russian
- **Problem approach**: Analyze and document issues comprehensively before proposing solutions
- **Architecture focus**: Prioritize understanding system relationships over quick fixes

### Development Methodology
- **Systematic approach**: Complete architectural audits before modifications
- **Testing verification**: Use Playwright for end-to-end verification
- **Documentation driven**: Maintain detailed Memory Bank for session continuity

## Project-Specific Patterns

### Data Access Patterns
```typescript
// SAFE: Check for null/undefined
const creatorName = creator.name || creator.fullName || creator.nickname || 'Unknown';

// UNSAFE: Direct property access
const creatorName = creator.name; // May be undefined
```

### Component Error Handling
```typescript
// SAFE: Defensive programming
{creator.subscribers ? creator.subscribers.toLocaleString() : '0'}

// UNSAFE: Assumes property exists
{creator.subscribers.toLocaleString()} // Crashes if undefined
```

### API Response Validation
```typescript
// SAFE: Validate API responses
const creators = await response.json();
if (!Array.isArray(creators)) {
  console.error('Invalid API response');
  return [];
}

// UNSAFE: Assume API structure
const creators = await response.json();
return creators.map(c => c.name); // May fail
```

## Known Challenges

### Schema Mismatch Issues
- **Root cause**: Migration from Supabase to PostgreSQL lost many fields
- **Symptoms**: TypeScript errors, runtime crashes, infinite loading states
- **Solution pattern**: Use normalizer service and null-safe component code

### WebSocket Authentication
- **Issue**: JWT token not properly passed from NextAuth to WebSocket server
- **Symptom**: WebSocket connections fail authentication
- **Investigation needed**: NextAuth session to JWT token flow

### Component State Management
- **Pattern**: Components show "Loading..." indefinitely when API/component mismatch occurs
- **Debug approach**: Check console errors, verify API responses, test component isolation

## Evolution Tracking

### Migration Decisions
- **Supabase to PostgreSQL**: Simplified schema, lost complex relationships
- **API simplification**: Created route-simple.ts versions to bypass broken Prisma queries
- **Component adjustments**: Added fallback patterns for missing data

### Technical Debt
- **PostNormalizer service**: Temporary solution masking architectural problems
- **Simplified APIs**: Limited functionality to avoid schema issues
- **Frontend assumptions**: Components built for different data structure than database provides

## Critical Files for Reference

### Always Check First
1. `memory-bank/` - Complete project context
2. `docs/ARCHITECTURE_COMPLETE_MAP.md` - System overview
3. `services/posts/normalizer.ts` - Data transformation patterns
4. `components/CreatorsExplorer.tsx` - Example of problematic component patterns

### Database Verification
```bash
# Verify actual database structure
psql "postgresql://fonana_user:fonana_pass@localhost:5432/fonana" -c "\d users"

# Check data quality
psql "postgresql://fonana_user:fonana_pass@localhost:5432/fonana" -c "SELECT nickname, fullName FROM users LIMIT 5"
```

### Testing Patterns
```bash
# Verify API endpoints
curl http://localhost:3000/api/creators | jq '.[0]'
curl http://localhost:3000/api/posts | jq '.[0].creator'

# Test frontend components
# Use Playwright to navigate to /creators and /feed pages
```

## Success Patterns

### Working Solutions
- **Simplified API routes**: Bypass complex relationships, focus on basic data retrieval
- **Memory Bank documentation**: Comprehensive system knowledge preservation
- **Playwright testing**: Real browser verification of frontend/backend integration
- **Defensive programming**: Null checks and fallback values prevent crashes
- **IDEAL METHODOLOGY**: 7-file systematic debugging prevents hasty fixes and ensures enterprise-quality solutions

### Effective Debugging
1. **API first**: Verify endpoints return expected data structure
2. **Component isolation**: Test components with known good data
3. **Console monitoring**: JavaScript errors reveal schema mismatches
4. **Database verification**: Check actual vs expected schema regularly
5. **Playwright MCP automation**: Real browser reproduction of issues
6. **Import validation**: Always check missing imports before complex debugging
7. **IDEAL METHODOLOGY application**: Follow systematic 7-phase approach for all non-trivial issues

Remember: This project has significant architectural debt that must be understood and worked around, not hastily "fixed" without comprehensive analysis. Always follow IDEAL METHODOLOGY for debugging to prevent time waste and ensure quality solutions. 